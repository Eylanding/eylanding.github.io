<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" href="index.css">
        <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <title>Custom Theories - Expidle Simplified guide</title>
    </head>
    <body>

       <header style="padding-left: 5%;">
            <a href="index.html"><h1>Exponential Idle Simplified Guides</h1></a>

            <ol class="nav_bar">
                <li><a href="0-2000.html">0-2000</a></li>
                <li><a href="IntroToGrad.html">Intro to Grad</a></li>
                <li><a href="2000-5000.html">2000-5000</a></li>
                <li><a href="Theories-1-to-4.html">T1-4</a></li>
                <li><a href="Theories-5-to-7.html">T5-7</a></li>
                <li><a href="Theory-8-and-R9.html">T8 & R9</a></li>
                <li><a href="Theory-9-to-endgame.html">T9 to Endgame</a></li>
                <li><b>Custom theories</b></li>
            </ol>

        </header>
        <div class="padded">

            <p><i>Previous: <a href="Theory-9-to-endgame.html">Theory 9 to Endgame</a></i></p>

            <h2>PLEASE READ <a href="index.html">GENERAL GUIDE</a> PAGE BEFORE READING THIS</h2>
            <h2>WIP THIS INFORMATION IS NOT PROOFREAD AND MAY BE INNACURATE</h2>
            <p><i>
                Disclaimer: This is a simplified version of the guide. The guide will skip over things, and is not completely
                optimal. Click <a href="https://exponential-idle-guides.netlify.app/">here</a> for a more polished, in-depth, and optimal guide.
            </i></p>


            <!--WSP-->
            <h2>Weierstraß sine product (WSP)</h2>
            <ul>
                <li><b>Sim time to completion:</b> 4 years and 333 days</li>
                <li><b>Dev:</b> Xaleroc</li>
                <li><b>Milestone route:</b> 0/0/3 → 0/1/3 → 4/1/3</li>
                <li><b>One sentence description:</b> TBA</li>
            </ul>
            <h3>T1 overview:</h3>
                <p>WSP is based of of Weierstrass' sine approximation: \(s_n(x) = x \Pi_{k=1}^n(1 - (\frac{x}{k\pi})^2)\).<br/>
                As n goes to infinity, sn(x) approaches sin(x)</p>
                <p>However, \(s_n(x)\) is quite inaccurate, and for large values of x, \(s_n(x)\) is much larger/smaller then sin(x), even for large values of n.<br/>
                Essentially, as x gets bigger, \(s_n(x) / sin(x)\) gets bigger, very fast, even for large values of n</p>
                <p>This theory exploits this inaccuracy, and uses it to increase \(\rho\)</p>

            <h3>Equation breakdown</h3>
                <blockquote>\(\dot{\rho} = q_1q_2q\)</blockquote>
                <blockquote>\(\dot{q} = c_2\frac{s_n(\chi)}{sin(\chi)}\)</blockquote>
                <blockquote>\(\chi = \pi \frac{c_1n}{c_1 + n / 3^3} + 1\)</blockquote>
                <p>These equation shows that to increase \(\rho\) you want to increase q</p>
                <p>To increase q you want to increase \(s_n(\chi) / sin(\chi)\), which is the stirling approximation from earlier.
                Thus to increase \(s_n(\chi) / sin(\chi)\), you want to increase \(\chi\).</p>
                <p>The third line shows how to increase \(\chi\)</p>
                <p>And thus we have the variable breakdown:</p>
                <table>
                    <tr><td>\(q_1\)</td><td>Increases \(\dot{\rho}\) directly by approx 7%</td></tr>
                    <tr><td>\(q_2\)</td><td>Increases \(\dot{\rho}\) directly by 2x</td></tr>
                    <tr><td>\(c_1\)</td><td>Increases \(\chi\) (affect changes over time)</td></tr>
                    <tr><td>\(n\)</td><td>Increases \(\chi\) (affect changes over time)</td></tr>
                    <tr><td>\(c_2\)</td><td>Increases \(\dot{q}\) by 2x</td></tr>
                </table>
                <p>\(c_1\) and \(n\) affect \(\dot{\rho}\) differently over time</p>
                <table>
                    <tr><td>\(c_1\)</td><td>Initially 50% increase in q. Decreases to 0 over time. Negligable after 1e400</td></tr>
                    <tr><td>\(n\)</td><td>Initially 50% increase in q. Increaces to 4x over time. Almost 4x after 1e400</td></tr>
                </table>

            <h3>Optimal publication multiplier:</h3>
                <ul>
                    <li>0 - e50: 2 - 4</li>
                    <li>e50 - e75: 5 - 7</li>
                    <li>e75+: ~8</li>
                </ul>

            <h3>Strategies:</h3>
                <p>The best strategy for WSP is always WSPdStopC1. This strategy changes to accommodate that changing power of \(c_1\) and \(n\). However, to
                simplify, I have a different strat written here: WSPdStopC1noMod. This is not a mainstream strat, so people may not know what you're talking
                about and the sim will not recommend it. The sim will recommend WSPdStopC1 instead.<br/>
                <a href="https://exponential-idle-guides.netlify.app/guides/theory-strategies/#wspdstopc1">WSPdStopC1</a></p>

                <h4>WSPdStopC1noMod</h4>

                <table>
                    <tr><th>var    </th><th>First 15s                         </th><th>Rest of pub                                                      </th></tr>
                    <tr><td>\(q_1\)</td><td style="color: green;">Always buy</td><td>When cost is \(\frac{1}{10}\) of \(min(q_2, n, c_2) cost\)       </td></tr>
                    <tr><td>\(q_2\)</td><td style="color: green;">Always buy</td><td style="color: green;">Always buy</td></tr>
                    <tr><td>\(c_1\)</td><td style="color: green;">Always buy</td><td>When cost is \(c_1\) ratio cheaper then \(min(q_2, n, c_2) cost\)</td></tr>
                    <tr><td>\(n\)  </td><td style="color: green;">Always buy</td><td style="color: green;">Always buy</td></tr>
                    <tr><td>\(c_2\)</td><td style="color: green;">Always buy</td><td style="color: green;">Always buy</td></tr>
                </table>
                <p>\(c_1\) ratio</p>
                <ul>
                    <li>0 - e25: 1</li>
                    <li>e25 - e40: 3</li>
                    <li>e40 - e200: 10</li>
                    <li>e200 - e400: 50</li>
                    <li>e400 - e700: 1000</li>
                    <li>e700+: Don't buy c1 more then 15 seconds into the publication</li>
                </ul>

                <p>The idle strat for WSPdStopC1 is WSPStopC1 (no d), which is slightly different from just autobuying all except those listed as never buy</p>
                <p>✔️ - Always buy, ❌ - Never buy</p>
                <h3>WSPStopC1</h3>
                <table>
                    <tr><th>var    </th><th>First 15s                         </th><th>Rest of pub                                                      </th></tr>
                    <tr><td>\(q_1\)</td><td>✔️</td><td>✔️</td></tr>
                    <tr><td>\(q_2\)</td><td>✔️</td><td>✔️</td></tr>
                    <tr><td>\(c_1\)</td><td>✔️</td><td>❌ unless \(\rho\) &lt 1e450 in which case ✔️</td></tr>
                    <tr><td>\(n\)  </td><td>✔️</td><td>✔️</td></tr>
                    <tr><td>\(c_2\)</td><td>✔️</td><td>✔️</td></tr>
                </table>

            <!--T2-->
            <h2>Sequential Limits (SL)</h2>
            <ul>
                <li><b>Sim time to completion:</b> 288 days</li>
                <li><b>Dev:</b> </li>
                <li><b>Milestone route:</b> 0/0/0/2 → 0/0/2/2 → 3/0/2/2 → 3/5/2/2</i></li>
                <li><b>One sentence description:</b> TBA</li>
            </ul>
            <h3>SL overview:</h3>
                <p>SL is based of a variation of stirlings approximation for e. Stirlings approximation is an expression that approaches e and x approches
                infinity:</p>
                <p>\(lim_{x \rightarrow \infty} \frac{x}{\sqrt[x]{x!}} = e\)</p>
                <p>In the theory \(\frac{x}{\sqrt[x]{x!}}\) is represetned the the symbol \(\gamma\)</p>
                <p>Essentially, the higher x is, the closer \(\gamma\) is to e</p>
                <p>Stirlings approximation is linear, that is, doubling x, makes \(\gamma\) twice as close to e</p>
                <p>Approximations like this are often used to calculate the value of e by plugging in larger and larger values for x</p>

            <h3>Equation breakdown</h3>
                <blockquote>\(\dot{\rho_1} = \frac{\sqrt{\rho_2}}{e - \gamma}\)</blockquote>
                <blockquote>\(\gamma = \frac{\rho_3}{\sqrt[\rho_3]{\rho_3!}}\)</blockquote>
                <blockquote>\(\dot{\rho_2} = a_1a_2a_3^{-ln(\rho_3)}\)</blockquote>
                <blockquote>\(\dot{\rho_3} = b_1b_2\)</blockquote>
                <blockquote>\(a_3 = 2\)</blockquote>
                <p>The first equation shows that \(\dot{\rho_1}\) is affected by \(\rho_2\) (half effectiveness) and how close \(\gamma\) is to e<br/>
                Half effectiveness means that quarupling \(\rho_2\) only doubles \(\rho_1\).</p>
                <p>The 2nd equation is stirlings approximation, and shows us that the closeness of gamma to e is proportional to \(\rho_3\)</p>
                <p>The next equations are simple and show that \(a_{12}\) increases \(\rho_2\) and \(b_{12}\) increases \(\rho_3\)</p>
                <p>Interestingly, \(\dot{\rho_2}\) is DECREASED by \(a_3\) and \(\rho_3\), meaning to increase \(\rho_2\) you should decrease those</p>
                <p>The final equation shows the value of \(a_3\) which can be lowered through milestones</p>

                <p>Overall the effectiveness of each variable is</p>
                <table>
                    <tr><td>\(a_1\)</td><td>Increases \(\dot{\rho_2}\) by approx 52%, though due to the square root this is only a 26% inclease in \(\rho_1\)</td></tr>
                    <tr><td>\(a_2\)</td><td>Increases \(\dot{\rho_2}\) by 2x</td></tr>
                    <tr><td>\(b_1\)</td><td>Increases \(\dot{\rho_3}\) by  approx 60%</td></tr>
                    <tr><td>\(b_2\)</td><td>Increases \(\dot{\rho_3}\) by 2x</td></tr>
                </table>

            <h3>Optimal publication multiplier:</h3>
            <ul>
                <li>0 - e90: 5 - 8</li>
                <li>e90 - e200: 9 - 9.5</li>
                <li>e200-e300: 6 - 8</li>
                <li>e300+: 7.5 - 8.5</li>
            </ul>

            <h3>Strategies:</h3>
            <p>every variable does not affect \(\rho_1\) directly, affecting either \(\rho_2\) or \(\rho_3\), which usually takes a while to build up. Therefore, near
            the end of a publication, you should stop buying them, because by the time the upgrades have built up, you've past the optimal pub multi. Thus we
            have the strat SLStopAd. I would like to remove the Mod part for simplicity, but I am afraid I may make the start unviable. Therefore I have
            decided NOT to list the active strat (SL is super idle anyway), as the speed gain from SLStopAd is rarely enough to justify using over the idle
            strat SLStopA.</p>
            <p><a href="https://exponential-idle-guides.netlify.app/guides/theory-strategies/#slstopad">SLStopAd</a></p>
            <h4>SLStopA</h4>
            <p>✔️ - Always buy, ❌ - Never buy</p>
            <table>
                <tr><th>var    </th><th>Pub multi &lt 4.5</th><th>Pub multi 4.5 - 6</th><th>Pub multi > 6</th></tr>
                <tr><td>\(a_1\)</td><td>✔️                </td><td>❌               </td><td>❌            </td></tr>
                <tr><td>\(a_2\)</td><td>✔️                </td><td>❌               </td><td>❌            </td></tr>
                <tr><td>\(b_1\)</td><td>✔️                </td><td>✔️                </td><td>❌            </td></tr>
                <tr><td>\(b_2\)</td><td>✔️                </td><td>✔️                </td><td>❌            </td></tr>
            </table>
            <p>SL has a MS strat as well. This MS strat is quite difficult, however, without manual buying it might be not too bad. It's also good at get some
            MS practice in, <s>and if I have to suffer SLMS you all do too</s>. Therefore I have decided to include SLMS here as well (again, SLMSd is not
            included)</p>
            <h4>SLMS</h4>
            <p class="important">SLMS is a DIFFICULT strat to perform. If you find it overly difficult, please feel free to ignore this section</p>
            <table>
                <tr><td>State 1</td><td>\(4 \rightarrow 3 \rightarrow 1 \rightarrow 2\) (prioritieses \(\rho_3\))</td>
                <tr><td>State 2</td><td>\(2 \rightarrow 1 \rightarrow 4 \rightarrow 3\) (prioritieses \(\rho_2\))</td>
                <tr><td>State 3</td><td>\(1 \rightarrow 2 \rightarrow 4 \rightarrow 3\) (prioritieses \(\rho_1\))</td>
            </table>
            <p>This notation tells you the priority order to buy milestones. For example \(4 \rightarrow 3 \rightarrow 1 \rightarrow 2\) means to max out the 4th
            milestone (from the top) then the 3rd then the 1st then the 2nd</p>
            <table>
                <tr><th>\(\rho\)      </th><th>State 1</th><th>State 2</th><th>State 3</th></tr>
                <tr><td>1e25 - 1e50  </td><td>5      </td><td>4      </td><td>1      </td></tr>
                <tr><td>1e50 - 1e75  </td><td>7      </td><td>6      </td><td>1      </td></tr>
                <tr><td>1e75 - 1e100 </td><td>12     </td><td>10     </td><td>1      </td></tr>
                <tr><td>1e100 - 1e150</td><td>20     </td><td>15     </td><td>1      </td></tr>
                <tr><td>1e150 - 1e175</td><td>8      </td><td>6      </td><td>1      </td></tr>
                <tr><td>1e175 - 1e200</td><td>1.5    </td><td>1      </td><td>SKIP   </td></tr>
                <tr><td>1e200 - 1e275</td><td>3      </td><td>SKIP   </td><td>1      </td></tr>
                <tr><td>1e275 - 1e300</td><td>2      </td><td>SKIP   </td><td>1      </td></tr>
            </table>
            <p>This table tells you when to swap to each state. Start in state 1 and read the number in the box (I'm calling it "n"). When your \(\rho_1\)
            reaches "n" times less then the next \(b_{12}\) upgrade, swap to State 2. Now you have a new "n". When your \(\rho_1\) again reaches "n" times less
            then the next \(b_{12}\) upgrade with the new "n", swap to State 3 (note that for one of the stages there is no swapping to state 3.). Finally, when
            you can afford and buy the upgrade, or your \(\rho\) drops back down due to another upgrade, swap back to State 1</p>
            <p>For variable purcahse, follow the SLStopA strat. Therefore you don't have to worry about variables and just focus on the MS. If you want to take a
            break, just leave it in state 1 and come back. Any amount of active play is beneficial</p>
            <p>This strategy is over 2x faster then SLStopA, so I suggest doing it if you can. Plus, it's more fun then just waiting</p>


            <!--T3-->
            <h2>Eulers Formula (EF)</h2>
            <ul>
                <li><b>Sim time to completion:</b> 132 days</li>
                <li><b>Dev:</b> Snaeky and peanut</li>
                <li><b>Milestone route:</b> 2/0 → 2/3/0 → 2/3/5/0 → 2/3/5/2/0 → 2/3/5/2/2</li>
                <li><b>One sentence description:</b> TBA</li>
            </ul>

            <h3>EF overview:</h3>
            <p>EF is based of eulers formula: \(e^{i\theta} = cos(\theta) + i sin(\theta)\), where \(i = \sqrt{-1}\), the imaginary unit<br/>
            This means that as you increase θ, \(e^{i\theta}\) spirals around the origin (0, 0), always keeping a distance of 1. (and an angle of θ radians)</p>
            <p>For those who don't know, a complex number is a number in the form a + bi. I won't fully explain complex number here, but it is in essence a 2d
            number, in the form a + bi incread of (x, y). if we set z = a + bi, then Re(z) = a, and Im(z) = b.</p>
            <p>If you imagine the unit circle centered at the origin, then the value \(e^{i\theta}\) can be thought of a point 1 unit away fro mthe origin and
            \(\theta\) radians around the circle</p>
            <p>This formula will be used to generate 2 currencies, R and I, which are used to increase \(rho\).</p>
            <p>The equations in the theory have already expanded out eulers formula, and will be understandable if you have a good grasp of trigenometry, even if 
            you don't understan complex numbers</p>
            <p>Note that this theory's rho to tau rate is uniquely 1.6, this means that one must only reach 375 rho to max it out, and that tau increase 4 times
            faster with respect to rho, making this theory faster then it may seem when compared to the other CT's. This theory can feel extremely slow compared
            to other theories but it is actually one of the fastest</p>

            <h3>Equation breakdown</h3>
            <blockquote>\(\dot{\rho} = a_1a_2a_3 \sqrt{tq^2 + R^2 + I^2}\)</blockquote>
            <blockquote>\(G(t) = g_r + g_i\)</blockquote>
            <blockquote>\(g_r = b_1b_2cos(t), g_i = c_1c_2sin(t)\)</blockquote>
            <blockquote>\(\dot{q} = q_1q_2\)</blockquote>
            <blockquote>\(\dot{R} = (g_r)^2, \dot{I} = -(g_i)^2\)</blockquote>
            <p>The first line is the main equation, which shows that to increase \(\rho\) you want to increase \(a_1\), \(a_2\), \(a_3\), t, and q (R and I are
            effectively meaningless due to \(tq^2\) out competing them)<br/>
            The second line is the graph, G(t) is the graph drawn on screen<br/>
            The third line is Eulers formula, describing how \(g_r\) and \(g_i\) behave. Note that because they are squared below, negative values are fine<br/>
            The forth line simple describes q<br/>
            And the fifth line describes how R and I grow, based on the square of \(g_r\) and \(g_i\)</p>
            <p>Note that even though R and I are meaningless in the main equation, they are used to buy \(b_{12}\), \(c_{12}\), and \(a_{23}\), making them quite
            important</p>
            <p>And thus we have the variable breakdown:</p>
            <table>
                <tr><td>\(\dot{t}\)</td><td>Increases \(\dot{t}\) by +0.25 (max 1)</td></tr>
                <tr><td>\(q_1\)</td><td>Increases \(\dot{q}\) by approx 7%</td></tr>
                <tr><td>\(q_2\)</td><td>Increases \(\dot{q}\) by 2x</td></tr>
                <tr><td>\(b_1\)</td><td>Increases \(\dot{R}\) by approx 14%</td></tr>
                <tr><td>\(b_2\)</td><td>Increases \(\dot{R}\) by approx 21%</td></tr>
                <tr><td>\(c_1\)</td><td>Increases \(\dot{I}\) by approx 20%</td></tr>
                <tr><td>\(c_2\)</td><td>Increases \(\dot{I}\) by approx 21%</td></tr>
                <tr><td>\(a_1\)</td><td>Increases \(\dot{\rho}\) by 2x</td></tr>
                <tr><td>\(a_2\)</td><td>Increases \(\dot{\rho}\) by 2x, costs R</td></tr>
                <tr><td>\(a_3\)</td><td>Increases \(\dot{\rho}\) by 2x, costs I</td></tr>
            </table>

            <h3>Optimal publication multiplier:</h3>
            <p>TBA</p>

            <h3>Stategy:</h3>
            <p>EF strategy involves d strats with variable's that cost \(\rho\), and balancing between b/c upgrades and \(a_2/a_3\) upgrades with variable that cost R/I.
            Always buy \(\dot{t}\) as soon as you can</p>
            <p>The idea with R and I are as follows: b/c upgrades increase R and I growth, but not \(\rho\). Early on, this is good becasue we need R and I to 
            buy \(a_{23}\), but later into the pub they are less valuble, as their bonus takes a while to actually take effect. Therefore, later into the pub,
            we should buy b/c upgrades less</p>

            <h4>EFAInoMod</h4>

            <table>
                <tr><th>var    </th><th>Recovery                             </th><th>Tau gain                             </th></tr>
                <tr><td>\(q_1\)</td><td>When \(\frac{1}{15}\) of \(q_2\) cost</td><td>When \(\frac{1}{15}\) of \(q_2\) cost</td></tr>
                <tr><td>\(q_2\)</td><td style="color: green;">Always buy   </td><td style="color: green;">Always buy   </td></tr>
                <tr><td>\(b_1\)</td><td style="color: green;">Always buy   </td><td>When \(\frac{1}{5}\) of \(a_2\) cost </td></tr>
                <tr><td>\(b_2\)</td><td style="color: green;">Always buy   </td><td>When \(\frac{1}{5}\) of \(a_2\) cost </td></tr>
                <tr><td>\(c_1\)</td><td style="color: green;">Always buy   </td><td>When \(\frac{1}{5}\) of \(a_3\) cost </td></tr>
                <tr><td>\(c_2\)</td><td style="color: green;">Always buy   </td><td>When \(\frac{1}{5}\) of \(a_3\) cost </td></tr>
                <tr><td>\(a_1\)</td><td>When \(\frac{1}{10}\) of \(q_2\) cost</td><td>When \(\frac{1}{10}\) of \(q_2\) cost</td></tr>
                <tr><td>\(a_2\)</td><td style="color: green;">Always buy   </td><td style="color: green;">Always buy   </td></tr>
                <tr><td>\(a_3\)</td><td style="color: green;">Always buy   </td><td style="color: green;">Always buy   </td></tr>
            </table>

            <p>The idle strat is EFSNAX not Autobuy All</p>
            <h4>EFSNAX</h4>
            <p>✔️ - Always buy, ❌ - Never buy</p>
            <table>
                <tr><th>var</th><th>Recovery</th><th>Tau gain</th></tr>
                <tr><td>\(q_1\)</td><td>✔️</td><td>❌</td></tr>
                <tr><td>\(q_2\)</td><td>✔️</td><td>✔️</td></tr>
                <tr><td>\(b_1\)</td><td>✔️</td><td>❌</td></tr>
                <tr><td>\(b_2\)</td><td>✔️</td><td>❌</td></tr>
                <tr><td>\(c_1\)</td><td>✔️</td><td>❌</td></tr>
                <tr><td>\(c_2\)</td><td>✔️</td><td>❌</td></tr>
                <tr><td>\(a_1\)</td><td>✔️</td><td>✔️</td></tr>
                <tr><td>\(a_2\)</td><td>✔️</td><td>✔️</td></tr>
                <tr><td>\(a_3\)</td><td>✔️</td><td>✔️</td></tr>
            </table>


            <!--T4-->
            <h2>Convergents to the Square root of 2 - CSR2</h2>
            <ul>
                <li><b>Sim time to completion:</b> 1 year 73 days</li>
                <li><b>Dev: </b> Solarion</li>
                <li><b>Milestone route:</b> 0/1/0 → 0/1/2 → 3/1/2</i></li>
                <li><b>One sentence description:</b> TBA</li>
            </ul>

            <h3>CSR2 overview:</h3>
            <p>CSR2 is based on a reccurence relation that computes sqrt(2), which is the following 2 sequences:</p>
            <ul>
                <li>The N sequence which goes: 1, 3, 7, 17, 41, 99...</li>
                <li>The D sequence which goes: 1, 2, 5, 12, 29, 70...</li>
            </ul>
            <p>Where the next term (\(N_m\)) is the previous term (\(N_{m-1}\)) times 2 plus the term before that (\(N_{m-2}\)), for both N and D, that is</p>
            <blockquote>\((N/D)_m = 2(N/D)_{m-1} + (N/D)_{m-2}\)</blockquote>
            <p>Interestingly, if we take the quotient of corresponding terms in both series (\(\frac{N_m}{D_m}\)) (like 1/1, 3/2, 7/5, 17/12 ect.) as we get
            further along, it approaches \(\sqrt{2}\). Essentially, as m approaches infinity, (\(\frac{N_m}{D_m}\)) approachs \(\sqrt{2}\)</p>

            <h3>Equation Breakdown</h3>
            <blockquote>\(\dot{\rho} = q_1q_2q\)</blockquote>
            <blockquote>\(\dot{q} = c_1c_2|\sqrt{2} - \frac{N_m}{D_m}|^{-1}\)</blockquote>
            <blockquote>\(N_m = 2N_{m-1} + N_{m-2}, N_0 = 1, N_1 = 3\)</blockquote>
            <blockquote>\(D_m = 2D_{m-1} + D_{m-2}, D_0 = 1, D_1 = 2\)</blockquote>
            <blockquote>\(m = n + log_2(c_2)\)</blockquote>
            <p>The first line is the main equation, which shows that to increase ρ you want to increase q1, q2, and q</p>
            <p>The second line is the equation for q, ehich shows that increase q you want to increase c1, c2, and get \(\frac{N_m}{D_m}\) closer to
            \(\sqrt{2}\)</p>
            <p>The third line and forth line is the recurrence relation described above, which shows to get \(\frac{N_m}{D_m}\) closer to \(\sqrt{2}\), you want
            to increase m.</p>
            <p>The fifth line is self explanatory</p>
            <p>Therefore, \(q_{12}\) affect \(\rho\) directly and \(c_{12}\) and \(n\) affects q directly (and by extention \(\rho\) indirectly)</p>
            <p>And thus we have the variable breakdown:</p>
            <table>
                <tr><td>\(q_1\)</td><td>Increases \(\dot{\rho}\) by approx. 7%</td></tr>
                <tr><td>\(q_2\)</td><td>Increases \(\dot{\rho}\) by 2x</td></tr>
                <tr><td>\(c_1\)</td><td>Increases \(\dot{q}\) by approx. 7%</td></tr>
                <tr><td>\(n\)  </td><td>Increases \(\dot{q}\) by 6x</td></tr>
                <tr><td>\(c_2\)</td><td>Increases \(\dot{q}\) by 22x!! (wtih full milestones)</td></tr>
            </table>
            <p>Without full milestones \(c_2\) increases \(\dot{q}\) by about 11.5x</p>
            <p>An increase in \(\dot{q}\) corresponds to an equivelent increase in \(\dot{\rho}\) over time</p>
            

            <h3>Optimal publication multiplier:</h3>
            <p>I've found it between 2 and 4.5 usually, but it varies</p>

            <h3>Strategies</h3>
            <p>CSR2's strat is pretty simple, really heavy d strats. Because of the large variable disparity, doing active strats is especially beneficial</p>
            <p>This is not the normal CSR2d recommended by the guide but I believe mine is slightly better. This is the only strat in this guide that is actually better</p>
            <h4>CSR2d+</h4>
            <table>
                <tr><td>\(q_1\)</td><td>10x cheaper then \(min(q_2, n, c_2)\)</td></tr>
                <tr><td>\(q_2\)</td><td>1.9x cheaper then \(min(n, c_2)\)</td></tr>
                <tr><td>\(q_1\)</td><td>10x cheaper then \(min(q_2, n, c_2)\)</td></tr>
                <tr><td>\(n\)</td><td>1.11x cheaper then \(c_2\)</td></tr>
                <tr><td>\(c_2\)</td><td style="color: green;">Always buy</td></tr>
            </table>
            <p>note that autobuying \(q_2\) and \(n\) is almost the same. In fact, that is the strat recommended by the guide</p>
            <p>There is a MS strat for CSR2. You can do CSR2XL x.xx explained 
            <a href="https://exponential-idle-guides.netlify.app/guides/theory-strategies/#csr2xl-xxx">here</a> or you can just do one swap at the end of your
            pub, which is swapping form the usual milestone route of "0/1/0 -> 0/1/2 -> 3/1/2" to "3/0 -> 3/1/0 -> 3/1/2" at the end of your pub, wait a bit, and
            then publish and swap back.</p>



            <h2>Fractional Integration - FI</h2>
            <p class="important">WARNING: THE FOLLOWING 2 CUSTOM THEORIES ARE QUITE NEW. STRATEGIES MAY BE INCORRECT AND EVERYTIHNG IS SUBJECT TO CHANGE. DO NOT
                TAKE WITH HIGH CONFIDENCE</p>
            <ul>
                <li><b>Sim time to completion:</b> 264 days</li>
                <li><b>Dev: </b> Snaeky, Gen, XLII</li>
                <li><b>Milestone route:</b> 1 → 1/1 → 1/1/0/1 → 1/1/0/2 → <span class="red">1/1/0/1/1</span> → 1/1/0/2/1 → 1/1/1/2/1 →
                <span class="red">1/1/0/2/1/1</span> → 1/1/1/2/1/1 → <span class="red">1/1/0/2/2/1</span> → 1/1/1/2/2/1	→ 1/1/2/2/2/1 →
                <span class="red">1/1/1/2/2/2</span> → 1/1/2/2/2/2 → 1/1/3/2/2/2 → <span class="red">1/1/2/2/3/2</span> → 1/1/3/2/3/2</i></li>
                <li><i><span class="red">Coloured</span> milestones are milestones you move into from perma levels</i></li>
                <li><b>One sentence description:</b> TBA</li>
            </ul>

            <h3>FI Overview</h3>
            <p>FI is based on the idea of a fractional integral. For example, half intgrating a function twice is the same as regular integrating it once</p>
            <p>The actual definition of a fractional integral is complicated but unimportant. The idea that is that it is a smooth way to interpolate from 
            a function (it's 0th integral) to its integral (or 1st integral). For example, the 0.01th integral of a function is very similar to the unchanged
            function, and the 0.99th integral is very similar to it's regular integral</p>
            <p>A good explanation of the fraction integral can be found on
            <a href="https://www.youtube.com/watch?v=2dwQUUDt5Is&t=1326s"> this youtube video</a></p>
            <p>Typically, a fractional integral is notated using this notation: \(_{\lambda}\int f(x)dx\), where \(\lambda\) is the fraction.<br/>
            For example, \(_{\frac{1}{2}}\int f(x) dx\) is the half integral of f(x)</p>

            <h3>Equation breakdown</h3>
            <blockquote>$$\dot{\rho} = tr\sqrt[\pi]{q/\pi} \rightarrow \dot{\rho} = trmn\sqrt[\pi]{\int_0^{q/\pi}g(x)dx}$$</blockquote>
            <blockquote>$$\dot{r} = (\int_0^{\pi}g(x)dx - _{\lambda}\int_0^{\pi}g(x)dx)^{-1}$$</blockquote>
            <blockquote>$$\dot{q} = q_1q_2$$</blockquote>
            <h4>g(x) eq</h4>
            <table>
                <tr><td>Milestone 0</td><td>$$1 - \frac{x^2}{2!} + \frac{x^4}{4!}$$</td></tr>
                <tr><td>Milestone 1</td><td>$$1 - \frac{x^3}{3!} + \frac{x^5}{5!}$$</td></tr>
                <tr><td>Milestone 2</td><td>$$\frac{x + \frac{x^2}{2} + \frac{x^3}{3} + \frac{x^4}{4} + \frac{x^5}{5}}{ln(10)}$$</td></tr>
                <tr><td>Milestone 3</td><td>$$1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \frac{x^5}{5!}$$</td></tr>
            </table>
            <h4>\(\lambda\) eq</h4>
            <table>
                <tr><td>Before K term</td><td>$$\frac{1}{2}$$</td></tr>
                <tr><td>Milestone 0  </td><td>$$\sum_{i=0}^{K}\frac{1}{2^i}$$</td></tr>
                <tr><td>Milestone 1  </td><td>$$\sum_{i=0}^{K}\frac{2}{3^i}$$</td></tr>
                <tr><td>Milestone 2  </td><td>$$\sum_{i=0}^{K}\frac{3}{4^i}$$/td></tr>
            </table>   
            <p>This main equation shows that \(\dot{\rho}\) is proportional to t, r, and \(\sqrt[\pi]q\)</p>
            <p>After the main equation changes it is proportional to t, r, m, n, and \(\sqrt[\pi]{(\int g)(q/\pi)}\)</p>
            <p>Now, g is always a polynomial, so to approximate the integral g(x) we can take the highest exponent in the polynomial and increase it by one to
            make a new, very simple polynomial. This of course, is not a very good approximation, it ignores coeficcients, but the exponent is the thing tha
            matters here. For example, the integral of the Milestone 0 equation can be thought of as \(x^5\), so after milestone 0, rho is proportional to
            \(\sqrt[\pi]{q^5}\) or \(q^{5/\pi} \approx q^{1.59}\) ignoring coefficients</p>
            <p>The fact that this exponent is higher then one, means tht q's affect on \(\dot{\rho}\) is greater then other variables</p>
            <p>The 2nd line is the equation for \(\dot{r}\). This equation shows that \(\dot{r}\) is proportional to how close the 2 integrals are.</p>
            <p>One integral is a normal integral, but the other is a fractional integral. As shown before, as the fraction approaches 1, the two integrals
            get closer together. Thus, as \(\lambda\) approaches one, the fractional integral approaches the normal integral, and \(\dot{r}\) increases</p>
            <p>The \(\lambda\) equations are all equations that converge to 1. The first equation adds 1/2 then 1/4 then 1/8. Each succesive addition moves
            half the remaining distance to 1, and slowly converges on it. The next equations do the same time, but instead of half the distance it's 2/3 or 3/4</p>
            <p>And thus, we can determine the strengths of each variable</p>
            <table>
                <tr><td>\(\dot{t}\)</td><td>Inreases \(\dot{t}\) by 0.25 each level, max 1</td></tr>
                <tr><td>\(q_1\)</td><td>Inreases \(\dot{q}\) by approx. 18% (50x every 23 levels)</td></tr>
                <tr><td>\(q_2\)</td><td>Inreases \(\dot{q}\) by 2x</td></tr>
                <tr><td>\(K\)</td><td>Inreases \(\dot{r}\) by 2x, 3x, or 4x depending on milestones</td></tr>
                <tr><td>\(m\)</td><td>Inreases \(\dot{\rho}\) by 1.5x</td></tr>
                <tr><td>\(m\)</td><td>Inreases \(\dot{\rho}\) by approx 10% (3x every 11 levels)</td></tr>
            </table>

            <h3>Strategy</h3>
            <p class="important">The theory is very new, so the strategies are not fully developed. These strategies are unoptimised and subject to change</p>
            <p>FI, having many time dependant variables, is a relatively idle theory, so autobuy all isn't too bad. FI, whilst having some of thw most complicated
            equations, really just has d strats and some basic MS (I say basic MS it's still kinda hard).</p>
            <p>Like many other theories, FI has a milestone swapping strat. The \(q_1\) exp milestones increase q gain, and the m and n variable milestones
            increase \(\dot{\rho}\). The way milestone swapping works is that every so often you swap to \(q_1\) exp to build up q, and then swap to  m and n
            variables to actually grow \(\rho\). The reason this works is that the benefit of having \(q_1\) milestones (i.e. high q) remain even after you
            swap out of them</p>
            <p>To perform MS you want to swap between the normal milestone route given about, and prioritising the \(q_1\) exponent milestone. The best way
            to descrbie it is that when your swapping your milestones, max out \(q_1\) exponent, then put you remaining milestones in the normal route. However,
            ALWAYS prioritise perma level locked upgrades over other upgrades. The buy order is \(q_1\) exp → perma level locked milestones → other milestones.
            Of course, if the milestone resets q, i.e. the g(x) milestone, don't respec it, just keep it bought</p>
            <h4>FId</h4>
            <p>Again, this strat is subject to change</p>
            <table>
                <tr><td>\(q_1\)</td><td>Buy at \(\frac{1}{10}\) of \(min(q_2, K, m)\)</td></tr>
                <tr><td>\(q_2\)</td><td style="color: green;">Always buy   </td></tr>
                <tr><td>\(K\)  </td><td style="color: green;">Always buy   </td></tr>
                <tr><td>\(m\)  </td><td style="color: green;">Always buy   </td></tr>
                <tr><td>\(m\)  </td><td>Buy at \(\frac{1}{10}\) of \(min(q_2, K, m)\)</td></tr>
            </table>


            <h2>Fractal Patterns - FP</h2>
            <ul>
                <li><b>Sim time to completion:</b> 103 days (theoriesed to be lower, sub 100)</li>
                <li><b>Dev: </b> XLII</li>
                <li><b>Milestone route:</b> 2 → 2/2 → 2/2/3 → 2/2/3/1 → 2/2/3/1/1 → 2/2/3/1/1/1</li>
                <li><b>One sentence description:</b> TBA</li>
            </ul>

            <h3>FP Overview</h3>
            <p>So you thought FI was complex? FP is based upon the growth of 3 fractals: The toothpick sequence, the Ulam-Warbuton callular automata and
            Sierpinski's triangle. Each fractal contributes to the main equation in their own way.</p>
            <p>The toothpick sequence is a fractal about toothpicks. Imagine a toothpick in 2d space with a length of 2 units. Every timestep, At each end of
            the toothpick add another toothpick, perpendicular to the original, with the midpoint of the new toothpick at the end of the old toothpick.
            \(T_n\) represents how many toothpicks there are after \(n\) timesteps. This is not an easy equation, as if 2 toothpick ends meet, they don't
            produce any more toothpicks, so the geometry of the problem is important. The toothpick sequence has interesting patterns around powers of 2,
            as one can see in the equations</p>
            <p>The Ulam-Warbuton cellular automaton is a fractal that is made for a cellular automata (like Conways game of life). The rule is this. Imagine
            a 2x2 infinite grid of cells, with one cell ON and the others all OFF. every time step, each OFF cell is turned ON if and only if it is
            neighbors (orthoginally, i.e. no diagonals) with exactly one ON cell. \(U_n\) rperesents the number of ON cells after \(n\) timesteps</p>
            <p>Sierpinski's triangle is a very well known fractal. If you are not already familiar with it, start with an equalateral triangle. Then, subdivide 
            it into 4 smaller, congruent equalateral triangles, and remove the middle one. This process is shown below. \(S_n\) represents how many triangles
            there are after \(n\) timesteps</p>
            <img src="images/Siepinski.png">

            <h3>Equation breakdown</h3>
            <p>Ok, I'm going to be real with you here. There is no way I'm breaking down the equation for each fractal. This guide will only go through the
            main equations.</p>
            <blockquote>$$\dot{\rho} = c_1c_2tT_n^7 \rightarrow \dot{\rho} = c_1c_2qtT_n^7 \rightarrow \dot{\rho} = c_1c_2qrtT_n^7
            \rightarrow \dot{\rho} = c_1c_2qrtT_n^{5+s}$$</blockquote>
            <blockquote>$$\dot{q} = q_1AU_n^7/1000 \rightarrow \dot{q} = q_1AU_n^{7+s}/1000$$</blockquote>
            <blockquote>$$\dot{r} = r_1(T_nU_n)^{log(n)}S_{\lfloor\sqrt{n}\rfloor} \rightarrow \dot{r} = r_1(T_nU_n)^{log(n)}S_{\lfloor\sqrt{n}\rfloor}^{2.8}
            \rightarrow \dot{r} = r_1(T_nU_n)^{\sqrt{2U_n}}S_{\lfloor\sqrt{n}\rfloor}^{2.8}$$</blockquote>
            <blockquote>$$A = (2 - U_{q_2}/T_{q_2})^{-1}$$</blockquote>
            <p>The first equation shows how \(\rho\) is increased. Interestingly, \(T_n\) is taken to the 7th power (or possibly higher), making it much stronger then other variables.
            \(T_n\) growth is approixmately a polynomial in n, so this term is a very high degree polynomial</p>
            <p>The second equation shows how q increases. \(U_n\) is again taken to the 7th power so it is again very strong.</p>
            <p>The third equation shows how r increases. \(log(n)\) is quite stable and only changes very slowly form 1 at the start to like 3 at the vary end of
            the theory. The \(S_{\lfloor \sqrt{n} \rfloor}\) part means that there is a jump by about 3x every time n hits a perfect square
            (or \(3^{2.8} \approx 21.6\))x after the milestone</p>
            <p>The forth equation describes A. Whilst the equation seems complicated, especially with \(\frac{T_{q_2}}{U_{q_2}}\) which seems to require understnading
            how the fractal patterns work, it is actually rather simple. Every \(q_2\) upgrade, A increases by 4x</p>
            <p>Thus we have the variable breakdown</p>
            <table>
                <tr><td>\(\dot{t}\)</td><td>Increases \(\dot{t}\) by 0.25 (max 1)</td></tr>
                <tr><td>\(c_1\)    </td><td>Increases \(\dot{\rho}\) by ~5% but varies between a &lt1% increase and a >2x increase</1></td></tr>
                <tr><td>\(c_2\)    </td><td>Increases \(\dot{\rho}\) by 2x</td></tr>
                <tr><td>\(q_1\)    </td><td>Increases \(\dot{q}\) by... about 25%? Again, difficult to describe</td></tr>
                <tr><td>\(q_2\)    </td><td>Increases \(\dot{q}\) by 4x, except for early levels of \(q_2\)</td></tr>
                <tr><td>\(r_1\)    </td><td>Increases \(\dot{r}\) by... about 10 - 20% Again again, this theory is complicated</td></tr>
                <tr><td>\(n\)      </td><td>Hard to describe, but is very strong</td></tr>
                <tr><td>\(s\)      </td><td>Increases like everything by alot, even stronger then n</td></tr>
            </table>
            <p>So FP is complicated. This is because of something called <b>stepwise variables</b>. These are variables who's increase changes. A more in depth
            description will be wirtten soon, but for now you are just going to have to accept my random numbers. This is what causes the complexity in
            \(c_1\), \(q_1\), and \(r_1\). This isn't too hard to explain but might be a bit beyond the scope of these guides, as of now. Stepwise variables are
            actually in every theory but this guide has been stubboornly ignoring them up until now, where FP uses stpewise variables in a different way, making
            their effect much more pronounced</p>
            <p>In the case of \(n\), it's power is connected with the fractal patterns, which are inherently very complicated, but it is clearly much more powerful
            than the rest.</p>
            <p>Finally \(s\) affects the exponent, which makes it very powerful. Upgrades are few and far between, but it is clearly to strongest variable by a lot</p>

            <h3>Strategy</h3>
            <p>Strategy in FP is mainly based around \(c_1\). Essentially, every 100 levels \(c_1\) get's a huge spike of power, but apart from those it is
            actually quite weak. Thus the best thing you can do is to actively buy \(c_1\). As you get more \(c_1\) it get weaker and weaker until you reach
            a multiple of 100, when it spikes in power and starts this cycle again.</p>
            <p>For \(c_1\) buying strats, take the lest 2 digits of \(c_1\)'s level. As \(c_1\) get's weaker as more of it gets bought the higher the value is the
            worse it is, but this resets every 100 levels. therefore, take the last 2 digits of \(c_1\)'s level and an indication of how weak it is. For manual
            buying, buy it at (last 2 digits of level) times less then \(min(c_2, q_2, n, s)\).</p>
            <p>For idle, autobuy \(c_1\) is quite bad, so once you reach a medium last 2 digits (Like 30), turn off autobuy and check in every hour to manual buy
            \(c_1\) to (last 2 digits of level) times less then \(min(c_2, q_2, n, s)\) and then go idle again. If \(c_1\) is close to resetting, like has a
            level of >90, you may want to turn on autobuy for \(c_1\) to hit the multiple of 100</p>
            <h4>FPd</h4>
            <table>
                <tr><td>\(\dot{t}\)</td><td style="color: green;">Always buy   </td></tr>
                <tr><td>\(c_1\)    </td><td>See above</1></td></tr>
                <tr><td>\(c_2\)    </td><td style="color: green;">Always buy   </td></tr>
                <tr><td>\(q_1\)    </td><td>When \(\frac{1}{10}\) of \(min(c_2, q_2, n, s)\) cost</td></tr>
                <tr><td>\(q_2\)    </td><td style="color: green;">Always buy   </td></tr>
                <tr><td>\(r_1\)    </td><td>When \(\frac{1}{10}\) of \(min(c_2, q_2, n, s)\) cost</td></tr>
                <tr><td>\(n\)      </td><td style="color: green;">Always buy   </td></tr>
                <tr><td>\(s\)      </td><td style="color: green;">Always buy   </td></tr>
            </table>
            <p><i>When 2 always buy variables are a similar cost, priority order is \(s > n > q_2 >\approx c_2\).</i></p>
            <p>Milestone swapping is an even bigger boost to progress then \(c_1\) manual buy and is about the most forced milestone swapping of any theory.
            The milestone that unlocks s can be detrimental to progress. For \(\dot{q}\), it is strictly beneficial, as the exponent goes from 7 to 7 + s, 
            making it stronger. However, for \(\dot{\rho}\), the exponent changes to 5 + s, making it weaker if s &lt 2, which it is before 1e950. Therefore,
            you should swap into the milestone to build q and then swap out of it the grow \(\dot{\rho}\)</p>
            <p>The main guides says this in reference to milestone swapping:</p>
            <div style="padding-left: 40px;border-left:1px solid black">
                <p>The swap is really hard to describe in terms of how long to keep it in and out but what can be said qualitatively:</p>
                <ul>
                    <li>At first, you follow very fast swaps to recover rho, and swaps gradually become slower and slower.</li>
                    <li>As s grows, it makes sense to keep the milestone swapped in longer.</li>
                </ul>
                <p>Milestone swap ends when s becomes > 2, and dies out when you can recover to that point very fast. Past ~e950 rho, recovery takes ~1-3 minutes of
                idle time.</p>
            </div>
            <p>Approximately, the end of a publication at about 1e900, each swap should take about 4 hours. You can use that as an anchor to estimate other times</p>
            <p>I have an alternate description which is more rigid</p>
            <ol>
                <li>Wait for a \(q_2\) or \(s\) purcahse</li>
                <li>Determine the ratio between \(\dot{rho}\) and the cost of your lowest doubling upgrade (Those listed as always buy on the strategy).<br/>
                <i>for example, if \(\dot{\rho}\) is 1e100, and the lowest doubling upgrade is \(c_2\) for 1e102, the ratio is 100</i></li>
                <li>Swap to s, and wait till the ratio of \(\dot{q}\) and \(q\) is 1 to 2 times the ratio determined earlier</li>
                <li>Swap back out of s</li>
                <li>Repeat</li>
            </ol>
            <p class="important">WARNING: This strategy is UNTESTED and may be very inefficient. Make sure to use common sense as well.</p>


        </div>
    </body>
</html>
